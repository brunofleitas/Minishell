/*
static int	count_words_tokens(char const *s, char c)
{
	int		counter;
	int		i;
	char	**split;
	int		word_length;
	int		i;

	i = 0;
	if (*s == '\0')
		return (0);
	counter = 0;
	while (s[i] != '\0')
	{
		if (s[i] == '"')
		{
			i++;
			while (s[i] != '"')
				i++;
			counter++;
		}
		if (s[i] == '\'')
		{
			i++;
			while (s[i] != '\'')
				i++;
			counter++;
		}
		else if (s[i] == '>')
		{
			// Incrementa el contador para el sÃ­mbolo '>'
			counter++;
		}
		else if (s[i] != c && (i == 0 || s[i - 1] == c))
			counter++;
		i++;
	}
	return (counter);
}*/

/*
static char	**ft_split_tokens(char const *s, char c)
{
	i = 0;
	split = (char **)malloc((count_words_tokens(s, c) + 1) * sizeof(char *));
	if (!s || !split)
		return (0);
	while (*s)
	{
		while (*s == c && *s)
			s++;
		if (*s)
		{
			if (*s == '"')
			{
				s++;
				word_length = 0;
				while (s[word_length] != '"' && s[word_length])
					word_length++;
				split[i++] = ft_substr(s, 0, word_length);
				s += word_length + 1;
			}
			else if (*s == '\'')
			{
				s++;
				word_length = 0;
				while (s[word_length] != '\'' && s[word_length])
					word_length++;
				split[i++] = ft_substr(s, 0, word_length);
				s += word_length + 1;
			}
			else if (*s == '>')
			{
				split[i++] = ft_substr(s, 0, 1);
				s++;
			}
			else
			{
				if (!ft_strchr(s, c) && !ft_strchr(s, '>'))
					word_length = ft_strlen(s);
				else if (ft_strchr(s, '>') && (!ft_strchr(s, c) || ft_strchr(s,
							'>') < ft_strchr(s, c)))
					word_length = (int)(ft_strchr(s, '>') - s);
				else
					word_length = (int)(ft_strchr(s, c) - s);
				split[i++] = ft_substr(s, 0, word_length);
				s += word_length;
			}
		}
	}
	split[i] = NULL;
	return (split);
}*/

/*static int	count_words_tokens(char const *s, char c)
{
	int		counter;
	int		i;
	char	quote;

	i = 0;
	counter = 0;
	if (*s == '\0')
		return (0);
	while (s[i] != '\0')
	{
		if (s[i] == '"' || s[i] == '\'')
		{
			quote = s[i++];
			while (s[i] != quote && s[i] != '\0')
				i++;
			counter++;
		}
		else if ((s[i] == '>' && s[i + 1] == '>') || (s[i] == '<' && s[i
				+ 1] == '<') || (s[i] == '&' && s[i + 1] == '&') || (s[i] == '|'
				&& s[i + 1] == '|'))
		{
			counter++;
			i++;
		}
		else if (s[i] == '>' || s[i] == '<' || s[i] == '(' || s[i] == ')'
			|| s[i] == '|')
			counter++;
		else if (s[i] == '$' && s[i + 1] == '?')
		{
			counter++;
			i++;
		}
		else if (s[i] == '$')
			counter++;
		else if (s[i] != c && (i == 0 || s[i - 1] == c))
			counter++;
		i++;
	}
	return (counter);
}*/

/*static char	**ft_split_tokens(char const *s, char c)
{
	int		i;
	int		word_length;
	char	**split;
	char	quote;
	int		len;

	i = 0;
	split = (char **)malloc((count_words_tokens(s, c) + 1) * sizeof(char *));
	if (!s || !split)
		return (0);
	while (*s)
	{
		while (*s == c && *s)
			s++;
		if (*s)
		{
			if (*s == '"' || *s == '\'')
			{
				quote = *s++;
				word_length = 0;
				while (s[word_length] != quote && s[word_length])
					word_length++;
				split[i++] = ft_substr(s, 0, word_length);
				s += word_length + (s[word_length] ? 1 : 0);
			}
			else if ((*s == '>' && *(s + 1) == '>') || (*s == '<' && *(s
						+ 1) == '<') || (*s == '&' && *(s + 1) == '&')
				|| (*s == '|' && *(s + 1) == '|'))
			{
				split[i++] = ft_substr(s, 0, 2);
				s += 2;
			}
			else if (*s == '>' || *s == '<' || *s == '(' || *s == ')'
				|| *s == '|' || (*s == '$' && *(s + 1) == '?') || *s == '$')
			{
				len = (*s == '$' && *(s + 1) == '?') ? 2 : 1;
				split[i++] = ft_substr(s, 0, len);
				s += len;
			}
			else
			{
				word_length = 0;
				while (s[word_length] && !strchr(" ><&()|$", s[word_length]))
					word_length++;
				split[i++] = ft_substr(s, 0, word_length);
				s += word_length;
			}
		}
	}
	split[i] = NULL;
	return (split);
}*/
