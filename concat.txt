
#include "./libft/headers/libft.h"
#include "./libft/headers/ft_printf.h"
#include <readline/history.h>
#include <readline/readline.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <limits.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>


/*
  t_token_type: An enumeration representing different types of tkns encountered
  in a minishell environment.
  Values:
	TOKEN_cmd_ECHO: Represents an echo cmd token.
	TOKEN_cmd_CD: Represents a change directory cmd token.
	TOKEN_cmd_PWD: Represents a print working directory cmd token.
	TOKEN_cmd_EXPORT: Represents an export cmd token.
	TOKEN_cmd_UNSET: Represents an unset cmd token.
	TOKEN_cmd_ENV: Represents an environment variable cmd token.
	TOKEN_REDIR_IN: Represents an input redirection token.
	TOKEN_REDIR_OUT: Represents an output redirection token.
	TOKEN_REDIR_APPEND: Represents an append redirection token.
	TOKEN_HEREDOC: Represents a here document token.
	TOKEN_PIPE: Represents a pipe token.
	TOKEN_AND: Represents an AND logical operator token.
	TOKEN_OR: Represents an OR logical operator token.
	TOKEN_ENV_VAR: Represents a variable token.
	TOKEN_EXIT_STATUS: Represents a variable exit status token.
	TOKEN_SINGLE_QUOTE: Represents a single-quoted string token.
	TOKEN_DOUBLE_QUOTE: Represents a double-quoted string token.
	TOKEN_ARGUMENT: Represents a general argument token.
	TOKEN_ERROR: Represents an error token.
*/
/*
typedef enum e_token_type
{
	TOKEN_ERROR ,
	TOKEN_cmd_ECHO,
	TOKEN_cmd_CD,
	TOKEN_cmd_PWD,
	TOKEN_cmd_EXPORT,
	TOKEN_cmd_UNSET,
	TOKEN_cmd_ENV,
	TOKEN_REDIR_IN,
	TOKEN_REDIR_OUT,
	TOKEN_REDIR_APPEND,
	TOKEN_HEREDOC,
	TOKEN_PIPE,
	TOKEN_AND,
	TOKEN_OR,
	TOKEN_ENV_VAR,
	TOKEN_EXIT_STATUS,
	TOKEN_SINGLE_QUOTE,
	TOKEN_DOUBLE_QUOTE,
	TOKEN_ARGUMENT,
}				t_token_type;
*/

typedef enum    e_builtins
{
    ECHO,
    CD,
    PWD,
    EXPORT,
    UNSET,
    ENV,
}				t_builtins;

typedef enum e_token_type
{
    TOKEN_BUILTIN,           // Regular words/cmds
    TOKEN_SINGLE_QUOTE,   // '
    TOKEN_DOUBLE_QUOTE,   // "
    TOKEN_REDIR_IN,       // <
    TOKEN_REDIR_OUT,      // >
    TOKEN_REDIR_APPEND,   // >>
    TOKEN_HEREDOC,        // <<
    TOKEN_PIPE,           // |
    TOKEN_ENV_VAR,        // $...
    TOKEN_EXIT_STATUS,    // $?
    TOKEN_AND,            // &&
    TOKEN_OR,             // ||
    TOKEN_LPAREN,         // (
    TOKEN_RPAREN,         // )
    TOKEN_WILDCARD,       // *
    TOKEN_EOF,            // End of input
    TOKEN_WORD,       // Is there an input? maybe this one we delete at some point let's see
    TOKEN_ERROR           // Error
} 			t_token_type;

/* ************************************************************************** */
/*                           STRUCTURE DEFINITIONS                            */                           
/* ************************************************************************** */


typedef struct  s_token
{
	t_token_type	type;
	char		    *value;
}				t_token;
/*
typedef struct s_main_args
{
    char    *input;
    t_ntc   *first_node;
    t_ntc   *first_env;
    t_token *tkns[1024];
    t_env   *env;
    t_astnode *node;
}               t_ma;
*/
typedef struct s_env
{
	char					**var;
	int						count;
    int                     capacity;  
}							t_env;
// Current capacity of the var array. I propose to add this to the struct in order to keep track of the current capacity of the var array. Here what I call capacity is the number of elements that the var array can hold at the moment. This is useful when we want to add a new element to the array. If the array is full, we can reallocate memory to increase the capacity of the array. This avoid calling ft_realloc_g_c for each new variable. We call it only when count == capacity.
/* ************************************************************************** */
/*                                  AST NODE                                  */                           
/* ************************************************************************** */

typedef enum e_nodetype 
{
    NODE_CMD_LINE,
    NODE_PIPELINE,
    NODE_cmd,
    NODE_SIMPLE_CMD,
    NODE_WORD,
    NODE_REDIRECTION
}			t_nodetype;

typedef struct s_astnode t_astnode;
struct s_astnode 
{
    t_nodetype type;
    union 
	{
        struct 
		{
            t_astnode *left;
            t_astnode *right;
            int operator;
        } cmd_line;

        struct 
		{
            t_astnode **cmds;
            int cmd_count;
        } pipeline;

        struct
		{
            t_astnode *words;
            t_astnode *redirections;
            int word_count;
            int redirection_count;
        } simple_cmd;

        struct
		{
            char *value;
            int type;
            t_astnode *next; // Linked list for words
        } word;

        struct
		{
            int type;
            char *file;
            t_astnode *next; // Linked list for redirections
        } redirection;
    } data;
};

/*
Structs in the Union: Each struct within the union represents different types of node-specific data:

- cmd_line: For cmd line nodes, it contains pointers to left and right nodes and an operator (AND/OR).

- pipeline: For pipeline nodes, it contains an array of cmds and the count of these cmds.

- simple_cmd: For simple cmd nodes, it contains arrays of words and redirections, and their respective counts.

- word: For word nodes, it contains a string value and a type indicating what kind of word it is.

- redirection: For redirection nodes, it contains a type of redirection and a file name.

*/

typedef struct  s_main_args
{
    
	t_ntc		*first_node;
    t_ntc		*first_env;
	t_token		*tkns[1024];
	t_env		*env;
}               t_ma;

/* ************************************************************************** */
/*                                   AST EXECUTION                            */
/* ************************************************************************** */

/* ***************************  EXECUTE_PIPELINE_ARGS  ********************** */

typedef struct  s_pipeline_args
{
    int     pipe_fds[2];
    int     input_fd;
    pid_t   pid;
    pid_t   last_pid;
    int     status;
    int     last_cmd;
}               t_pip_args;

/* *************************  EXECUTE_SIMPLE_CMD_ARGS  ********************* */

typedef struct  s_simple_cmd_args
{
    int     word_count;
    int     status;
    char    **words_arr;
    int     saved_stdin;
    int     saved_stdout;
}               t_s_cmd_args;

/* ************************************************************************** */
/*                                   FUNCTIONS                                */
/* ************************************************************************** */
t_env           *duplicate_vars(t_ntc **first_node, char **envp);
void            lexer(char *input,t_token **tkns, t_ntc **first_node);
int             count_w_tks(char const *s, char c);
char            **ft_split_tkns(char const *s, char c, t_ntc **first_node);
t_token_type    clasify_token(char *value);
t_astnode       *parser(t_ntc **first_node, t_token **tkns);
t_astnode       *create_ast_node(t_ntc **first_node, t_nodetype type);
t_astnode       *parse_cmd_line(t_ntc **first_node, t_token *c_tkn, t_token **tkns);
t_token         *get_next_token(t_token **tkns, int t);
int             execute_builtin(char **args, t_ma *ma);
int             is_builtin(const char *word);
int             execute_cmd_line(t_astnode *node, t_ma *ma);
int             execute_pipeline(t_astnode *node, t_ma *ma);
int             execute_simple_cmd(t_astnode *node, t_ma *ma);
int             execute_external_cmd(char **words_arr, t_ma *ma);
t_astnode       *parse_word_list(t_ntc **first_node, t_token *c_tkn, t_token **tkns, t_astnode **last_word);
int             builtin_pwd(char **args, t_ma *ma);
int             builtin_echo(char **args, int count_words, t_ma *ma);
int             builtin_env(char **args, t_ma *ma);
int             builtin_export(char **args, t_ma *ma);
int             builtin_unset(char **args, t_ma *ma);
int             builtin_cd(char **args, t_ma *ma);
int             find_env_var(t_env **env, char *var);
int             execute_ast(t_astnode *node, t_ma *ma);
pid_t           fork_process();
int	update_env_var(int i, const char *var, t_ma *ma);

void	print_env(t_env *env);


static int	count_env_vars(char **envp)
{
	int	count;

	count = 0;
	while (envp[count])
		count++;
	return (count);
}

static char	**allocate_env(t_ntc **first_node, int count)
{
	char	**new_envp;

	new_envp = (char**)g_c(first_node, (count + 1) * sizeof(char *))->data;
	if (!new_envp)
	{
		perror("malloc");
		return (NULL);
	}
	return (new_envp);
}
/*
static void	free_env_vars(t_ntc **first_node, t_env *env)
{
	int	i;

	i = 0;
	while (i < env->count)
	{
		free_ntc_prior(first_node, env->var[i]);
		i++;
	}
	//free_ntc_prior(first_node, env);
}
*/
t_env	*duplicate_vars(t_ntc **first_node, char **envp)
{
	t_env	*env;
	int		i;

	env = g_c(first_node, sizeof(t_env))->data;
	env->count = count_env_vars(envp);
	env->var = allocate_env(first_node, env->count);
	if (!env->var)
		return (env);
	i = 0;
	while (i < env->count)
	{
		env->var[i] = ft_strdup_g_c(envp[i], first_node);
		if (!env->var[i])
		{
			perror("ft_strdup_g_c");
			free_memory(first_node);
			exit(1);
			//free_env_vars(first_node, env);
		}
		i++;
	}
	env->var[env->count] = NULL;
	//print_env(env);
	return (env);
}

void	print_env(t_env *env)
{
	int i;

	i = 0;
	while (env->var[i])
	{
		printf("%s\n", env->var[i]);
		i++;
	}
}

void	lexer(char *input,t_token **tkns, t_ntc **first_node)
{
	char	**split;
	int		i;

	i = 0;
	split = ft_split_tkns(input, ' ', first_node);
	while (split[i])
	{
		tkns[i] = g_c(first_node, sizeof(t_token))->data;
		tkns[i]->value = split[i];
		tkns[i]->type = clasify_token(tkns[i]->value);
		//ft_printf("%s\nType : %i\n\n", tkns[i]->value, tkns[i]->type);
		i++;
	}
	tkns[i] = NULL;
	free_ntc_prior(first_node, split);
}

static int	handle_quotes(const char *s, int *i)
{
	char	quote;

	quote = s[(*i)++];
	while (s[*i] != quote && s[*i] != '\0')
		(*i)++;
	return (1);
}

/*
  Parameters:
    s: Input string.
    i: Pointer to an integer indicating the current position in the string.
  Return value:
    1 if the function successfully identifies a double operator, otherwise
	returns 0.
  Description:
    Checks for occurrences of double operators ('>>', '<<', '&&', '||') in the 
	input string.
    Advances the position indicator if a double operator is found and returns 1.
    Otherwise, returns 0.
*/
static int	handle_double_operators(const char *s, int *i)
{
	if ((s[*i] == '>' && s[*i + 1] == '>') 
		|| (s[*i] == '<' && s[*i + 1] == '<')
		|| (s[*i] == '&' && s[*i + 1] == '&') 
		|| (s[*i] == '|' && s[*i + 1] == '|'))
	{
		(*i)++;
		return (1);
	}
	return (0);
}

/*
  Parameters:
    s: Input string.
    i: Pointer to an integer indicating the current position in the string.
  Return value:
    1 if the function successfully identifies a single operator or special 
	character, otherwise returns 0.
  Description:
    Identifies single operators ('>', '<', '|') and special characters ('$') 
	in the input string.
    Specifically, it checks for the sequence '$?' and increments the position 
	indicator if found. Returns 1 upon identifying a valid character or 
	sequence, otherwise returns 0.
*/
static int	handle_single_operators_and_specials(const char *s, int *i)
{
	if (s[*i] == '>' 
		|| s[*i] == '<' 
		|| s[*i] == '(' 
		|| s[*i] == ')'
		|| s[*i] == '|' 
		|| (s[*i] == '$' && s[*i + 1] == '?') 
		|| s[*i] == '$')
	{
		if (s[*i] == '$' && s[*i + 1] == '?')
			(*i)++;
		return (1);
	}
	return (0);
}

/*
  Parameters:
    s: Input string.
    c: Character used to separate tkns.
  Return value:
    Number of tkns found in the input string.
  Description:
    Counts the number of tkns in the input string, considering various
	conditions such as quotes, double operators, single operators, and
	special characters. tkns are incremented based on whether they 
	are surrounded by the separator character or are adjacent to it but 
	not immediately preceded by it.
*/
int	count_w_tks(char const *s, char c)
{
	int	counter;
	int	i;

	counter = 0; 
	i = 0;
	if (*s == '\0')
		return (0);
	while (s[i] != '\0')
	{
		if (s[i] == '"' || s[i] == '\'')
			counter += handle_quotes(s, &i);
		else if (handle_double_operators(s, &i)
			|| handle_single_operators_and_specials(s, &i))
			counter++;
		else if (s[i] != c && (i == 0 || s[i - 1] == c))
			counter++;
		i++;
	}
	return (counter);
}


/*
  Parameters:
	s: Pointer to the input string.
	split: Pointer to the array of pointers to strings (tkns).
	i: Pointer to an integer indicating the current index in the tkns array.
  Description:
	Extracts and stores a quoted word from the input string into the tkns 
	array.
	Increments the index in the tkns array and advances the input string past 
	the extracted word. Handles both single and double quotes. Adjusts the 
	advancement of the input string based on whether the quote ends at the end 
	of the line or not.
*/
static void	generate_quotes(const char **s, char ***split, int *i, t_ntc **first_node)
{
	char	quote;
	int		word_length;

	quote = **s;
	(*s)++;
	word_length = 0;
	while ((*s)[word_length] != quote && (*s)[word_length])
		word_length++;
	(*split)[(*i)++] = ft_substr_g_c(*s, 0, word_length, first_node);
	if ((*s)[word_length] != '\0')
		*s += word_length + 1;
	else
		*s += word_length;
}

/*
  Parameters:
    s: Pointer to the input string.
    split: Pointer to the array of pointers to strings (tkns).
    i: Pointer to an integer indicating the current index in the tkns array.
  Description:
    Extracts and stores a double operator (e.g., '>>', '<<', '&&', '||') from 
	the input string into the tkns array. Advances the input string by 2 
	positions to skip the operator.
*/
static void	generate_double_operators(const char **s, char ***split, int *i, \
															t_ntc **first_node)
{
	(*split)[(*i)++] = ft_substr_g_c(*s, 0, 2, first_node);
	*s += 2;
}

/*
  Parameters:
    s: Pointer to the input string.
    split: Pointer to the array of pointers to strings (tkns).
    i: Pointer to an integer indicating the current index in the tkns array.
  Description:
    Extracts and stores a single operator or special character (including '$?') 
	from the input string into the tkns array. The length of the substring 
	depends on the specific operator or special character.
    Advances the input string by the length of the extracted substring.
*/
static void	generate_single_operators_and_specials(const char **s,
		char ***split, int *i, t_ntc **first_node)
{
	int	len;

	len = 1;
	if (**s == '$' && *(*s + 1) == '?')
		len = 2;
	(*split)[(*i)++] = ft_substr_g_c(*s, 0, len, first_node);
	*s += len;
}

/*
  Parameters:
    s: Pointer to the input string.
    split: Pointer to the array of pointers to strings (tkns).
    i: Pointer to an integer indicating the current index in the tkns array.
  Description:
    Extracts and stores a regular token (any sequence of characters not 
	matching the specified operators or special characters) from the input 
	string into the tkns array. Calculates the length of the token by finding 
	the first occurrence of an operator or special character. Advances the 
	input string by the length of the extracted token.
*/
static void	generate_regular_tkns(const char **s, char ***split, int *i, \
																t_ntc **first_node)
{
	int	word_length;

	word_length = 0;
	while ((*s)[word_length] && !strchr(" ><&()|$", (*s)[word_length]))
		word_length++;
	(*split)[(*i)++] = ft_substr_g_c(*s, 0, word_length, first_node);
	*s += word_length;
}

/*
  Parameters:
	s: Input string to be split into tkns.
	c: Character used to determine token boundaries.
  Return value:
	A pointer to an array of strings, each representing a token from the input
	string.
	Returns NULL if the input string or the allocated memory cannot be processed
  Description:
	Splits the input string into tkns based on the specified delimiter
	character.
	Handles various cases including quotes, double operators, single operators,
	and regular tkns. Allocates memory for the resulting array of tkns and
	initializes it accordingly. The last element of the array is set to NULL
	to indicate the end.
*/
char	**ft_split_tkns(char const *s, char c, t_ntc **first_node)
{
	char	**split;
	int		i;

	i = 0;
	split = g_c(first_node, (count_w_tks(s, c) + 1) * sizeof(char *))->data;
	if (!s || !split)
		return (NULL);
	while (*s)
	{
		if (*s == c)
			s++;
		else if (*s == '"' || *s == '\'')
			generate_quotes(&s, &split, &i, first_node);
		else if ((*s == '>' && *(s + 1) == '>') || (*s == '<' && *(s
					+ 1) == '<') || (*s == '&' && *(s + 1) == '&') || (*s == '|'
				&& *(s + 1) == '|'))
			generate_double_operators(&s, &split, &i, first_node);
		else if (*s == '>' || *s == '<' || *s == '(' || *s == ')' || *s == '|'
			|| (*s == '$' && *(s + 1) == '?') || *s == '$')
			generate_single_operators_and_specials(&s, &split, &i, first_node);
		else
			generate_regular_tkns(&s, &split, &i, first_node);
	}
	split[i] = NULL;
	return (split);
}


static t_token_type	classify_cmd(char *value)
{
	if (ft_strcmp(value, "echo") == 0 
	|| ft_strcmp(value, "cd") == 0 || ft_strcmp(value, "pwd") == 0\
	|| ft_strcmp(value, "export") == 0 || ft_strcmp(value, "unset") == 0\
	|| ft_strcmp(value, "env") == 0)
		return (TOKEN_BUILTIN);
	return (TOKEN_ERROR);
}

static t_token_type	classify_operator(char *value)
{
	if (ft_strcmp(value, "<") == 0)
		return (TOKEN_REDIR_IN);
	if (ft_strcmp(value, ">") == 0)
		return (TOKEN_REDIR_OUT);
	if (ft_strcmp(value, ">>") == 0)
		return (TOKEN_REDIR_APPEND);
	if (ft_strcmp(value, "<<") == 0)
		return (TOKEN_HEREDOC);
	if (ft_strcmp(value, "|") == 0)
		return (TOKEN_PIPE);
	if (ft_strcmp(value, "&&") == 0)
		return (TOKEN_AND);
	if (ft_strcmp(value, "||") == 0)
		return (TOKEN_OR);
	return (TOKEN_ERROR);
}

static t_token_type	classify_variable(char *value)
{
	if (value[0] == '$' && value[1] == '?')
		return (TOKEN_EXIT_STATUS);
	if (value[0] == '$')
		return (TOKEN_ENV_VAR);
	return (TOKEN_ERROR);
}

static t_token_type	classify_string(char *value)
{
	if (value[0] == '\'' && value[ft_strlen(value) - 1] == '\'')
		return (TOKEN_SINGLE_QUOTE);
	if (value[0] == '"' && value[ft_strlen(value) - 1] == '"')
		return (TOKEN_DOUBLE_QUOTE);
	return (TOKEN_ERROR);
}

t_token_type	clasify_token(char *value)
{
	int	token_type;

	token_type = classify_cmd(value);
	if (token_type != TOKEN_ERROR)
		return (TOKEN_BUILTIN);
	token_type = classify_operator(value);
	if (token_type != TOKEN_ERROR)
		return (token_type);
	token_type = classify_variable(value);
	if (token_type != TOKEN_ERROR)
		return (token_type);
	token_type = classify_string(value);
	if (token_type != TOKEN_ERROR)
		return (token_type);
	if (ft_strlen(value) > 0)
		return (TOKEN_WORD);
	return (TOKEN_ERROR);
}


t_astnode *parser(t_ntc **first_node, t_token **tkns) 
{
    t_token     *c_tkn;
    t_astnode   *cmd_line;

    //printf("parser start\n");
    c_tkn = NULL;
    c_tkn = get_next_token(tkns, 1);
    cmd_line = parse_cmd_line(first_node, c_tkn, tkns);
    //printf("parser ends\n");
    return (cmd_line);
}

t_astnode *create_ast_node(t_ntc **first_node, t_nodetype type) 
{
    t_astnode *node;
    
    node = g_c(first_node, sizeof(t_astnode))->data;
    if (!node)
    {
        fprintf(stderr, "Error: Memory allocation failed\n");
        exit(1);
    }
    node->type = type;
    //printf("Node created: %i\n", node->type);
    return (node);
}

static int is_word_token(t_token_type type) 
{
    //printf("is_word_token start\n");
    //printf("is_word_token end\n");
    return (type == TOKEN_BUILTIN || type == TOKEN_SINGLE_QUOTE || 
            type == TOKEN_DOUBLE_QUOTE || type == TOKEN_ENV_VAR ||
            type == TOKEN_EXIT_STATUS || type == TOKEN_WILDCARD ||
            type == TOKEN_WORD);
}

/* 
 * Checks if the given token type is a redirection token.
 * Returns 1 if it is, 0 otherwise.
 */
static int is_redirection_token(t_token_type type) 
{
    //printf("is_redirection_token start\n");
    //printf("is_redirection_token end\n");
    return (type == TOKEN_REDIR_IN || type == TOKEN_REDIR_OUT ||
            type == TOKEN_REDIR_APPEND || type == TOKEN_HEREDOC);
}

/* 
 * Parses a list of redirections.
 * Returns the head of a linked list of redirection nodes.
 */
static t_astnode *parse_redirection_list(t_ntc **first_node, t_token *c_tkn, t_token **tkns, t_astnode **last_word) 
{
    t_astnode *head;
    t_astnode *current;
    t_astnode *redir_node;
    
    //printf("parse_redirection_list start\n");
    head = NULL;
    current = NULL;
    while (is_redirection_token(c_tkn->type)) 
    {
        redir_node = create_ast_node(first_node, NODE_REDIRECTION);
        redir_node->data.redirection.type = c_tkn->type;
        c_tkn = get_next_token(tkns, 1);
        if (!is_word_token(c_tkn->type))
        {
            fprintf(stderr, "Error: Expected filename after redirection\n");
            exit(1);
        }
        redir_node->data.redirection.file = c_tkn->value; //ft_strdup_g_c(c_tkn->value, first_node);
        c_tkn = get_next_token(tkns, 1);
        if (!head) 
        {
            head = redir_node;
            current = head;
        }
        else
        {
            current->data.redirection.next = redir_node;
            current = redir_node;
        }
        if (is_word_token(c_tkn->type))
            (*last_word)->data.word.next = parse_word_list(first_node, c_tkn, tkns, last_word);
    }
    if (current)
        current->data.redirection.next = NULL;
    //printf("parse_redirection_list end\n");
    return (head);
}

/* 
 * Parses a list of words (cmd and its arguments).
 * Returns the head of a linked list of word nodes.
 */
t_astnode *parse_word_list(t_ntc **first_node, t_token *c_tkn, t_token **tkns, t_astnode **last_word) 
{
    t_astnode *head;
    t_astnode *current;
    t_astnode *word_node;

    head = NULL;
    current = NULL;
    while (c_tkn && is_word_token(c_tkn->type)) 
    {
        word_node = create_ast_node(first_node, NODE_WORD);
        word_node->data.word.value = c_tkn->value; //ft_strdup_g_c(c_tkn->value, first_node);//this might be unnecessary as I don't think we need to recreate a malloc for this token as it is already stored int the tkns** array.
        word_node->data.word.type = c_tkn->type;
        if (!head) 
        {
            head = word_node;
            current = head;
        }
        else
        {
            current->data.word.next = word_node;
            current = word_node;
        }
        c_tkn = get_next_token(tkns, 1);
    }
    if (current)
    {
        *last_word = current;
        current->data.word.next = NULL;
    }
    t_astnode *temp = head;
    while (temp)
    {
        temp = temp->data.word.next;
    }
    return (head);
}

/* 
 * Parses a simple cmd, which consists of a word list (cmd and its arguments)
 * and an optional list of redirections.
 * Returns a node representing the simple cmd.
 */
static t_astnode *parse_simple_cmd(t_ntc **first_node, t_token *c_tkn, t_token **tkns) 
{
    t_astnode *node;
    t_astnode *last_word;
    
    //printf("parse_simple_cmd start\n");
    node = create_ast_node(first_node, NODE_SIMPLE_CMD);
    //if (c_tkn)
    //{
     //   printf("c_tkn->type: %s\n", c_tkn->value);
    //}
    node->data.simple_cmd.words = parse_word_list(first_node, c_tkn, tkns, &last_word);
    node->data.simple_cmd.redirections = parse_redirection_list(first_node, c_tkn, tkns, &last_word);
    //printf("parse_simple_cmd end\n");
    return (node);
}

/* 
 * Parses a cmd, which can be either a simple cmd or a cmd line
 * enclosed in parentheses.
 * Returns a node representing the cmd.
 */
static t_astnode *parse_cmd(t_ntc **first_node, t_token *c_tkn, t_token **tkns) 
{
    t_astnode *node;

    //printf("parse_cmd start\n");
    if (c_tkn->type == TOKEN_LPAREN) 
    {
        c_tkn = get_next_token(tkns, 1);
        node = parse_cmd_line(first_node, c_tkn, tkns);
        if (c_tkn->type != TOKEN_RPAREN) 
        {
            fprintf(stderr, "Error: Expected closing parenthesis\n");
            exit(1);
        }
        c_tkn = get_next_token(tkns, 1);
        //printf("parse_cmd end\n");
        return (node);
    } 
    else 
    {
        //printf("parse_cmd end\n");
        return parse_simple_cmd(first_node, c_tkn, tkns);
    }
}

/* 
 * Parses a pipeline, which is a sequence of cmds connected by pipes (|).
 * Returns a node representing the pipeline.
 */
static t_astnode *parse_pipeline(t_ntc **first_node, t_token *c_tkn, t_token **tkns) 
{
    t_astnode *node;
    
    //printf("parse_pipeline start\n");
    node = create_ast_node(first_node, NODE_PIPELINE);
    node->data.pipeline.cmds = g_c(first_node, sizeof(t_astnode*))->data;
    node->data.pipeline.cmds[0] = parse_cmd(first_node, c_tkn, tkns);
    node->data.pipeline.cmd_count = 1;
    
    while (c_tkn->type == TOKEN_PIPE) 
    {
        c_tkn = get_next_token(tkns, 1);
        node->data.pipeline.cmd_count++;
        node->data.pipeline.cmds = ft_realloc_g_c(first_node,\
                                        node->data.pipeline.cmds,\
                                        node->data.pipeline.cmd_count\
                                        * sizeof(t_astnode*));
        /* node->data.pipeline.cmds = realloc(node->data.pipeline.cmds,\
                                        node->data.pipeline.cmd_count\
                                        * sizeof(t_astnode*)); */
        node->data.pipeline.cmds[node->data.pipeline.cmd_count - 1]\
                                = parse_cmd(first_node, c_tkn, tkns);
    }
    //printf("parse_pipeline end\n");
    return (node);
}

/* 
 * Parses a cmd line, which can be a single pipeline or multiple pipelines
 * connected by AND (&&) or OR (||) operators.
 * Returns the root node of the parsed cmd line.
 */
t_astnode *parse_cmd_line(t_ntc **first_node, t_token *c_tkn, t_token **tkns) 
{
    t_astnode *node;
    t_astnode *new_node;
    
    //printf("parse_cmd_line start\n");
    node = parse_pipeline(first_node, c_tkn, tkns);
    while (c_tkn->type == TOKEN_AND || c_tkn->type == TOKEN_OR) 
    {
        new_node = create_ast_node(first_node, NODE_CMD_LINE);
        new_node->data.cmd_line.left = node;
        new_node->data.cmd_line.operator = c_tkn->type;
        c_tkn = get_next_token(tkns, 1);
        new_node->data.cmd_line.right = parse_pipeline(first_node, c_tkn, tkns);
        node = new_node;
    }
    //printf("parse_cmd_line end\n");
    return (node);
}

t_token *get_next_token(t_token **tkns, int t) 
{
    static int i;

    if (t == 0)
    {
        i = 0;
        return  (NULL);
    }
    if (!tkns[i])
    {
        return (NULL);
    }
    return (tkns[i++]);
}

